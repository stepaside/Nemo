using Nemo.Attributes;
using Nemo.Attributes.Converters;
using Nemo.Id;
using Nemo.Reflection;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Linq.Expressions;
using System.Reflection;

namespace Nemo.Configuration.Mapping
{
    public class PropertyMap<T, TProperty> : IPropertyMap
        where T : class
    {
        private readonly ReflectedProperty _property;
        private readonly Expression<Func<T, TProperty>> _selector;
        private bool _not;

        public PropertyMap(Expression<Func<T, TProperty>> selector, bool not = false)
        {
            _selector = selector;
            _not = not;
            
            var property = (PropertyInfo)((MemberExpression)selector.Body).Member;
            _property = new ReflectedProperty(property, readAttributes: false);
        }

        public PropertyMap<T, TProperty> Not
        {
            get
            {
                _not = true;
                return this;
            }
        }

        public PropertyMap<T, TProperty> PrimaryKey(int position = 0)
        {
            _property.IsPrimaryKey = !_not;
            _property.KeyPosition = position;
            _not = false;
            return this;
        }

        public PropertyMap<T, TProperty> Generated(Type generator = null)
        {
            if (generator != null && typeof(IIdGenerator).IsAssignableFrom(generator))
            {
                _property.Generator = generator;
                _property.IsAutoGenerated = false;
            }
            else
            {
                _property.Generator = null;
                _property.IsAutoGenerated = !_not;
            }
            _not = false;
            return this;
        }

        public PropertyMap<T, TProperty> References<TParent>(int position = 0)
            where TParent : class
        {
            _property.Parent = typeof(TParent);
            _property.RefPosition = position;
            _not = false;
            return this;
        }

        public PropertyMap<T, TProperty> Parameter(string name, ParameterDirection direction = ParameterDirection.Input)
        {
            _property.ParameterName = name;
            _property.Direction = direction;
            _not = false;
            return this;
        }

        public PropertyMap<T, TProperty> Persistent()
        {
            _property.IsPersistent = !_not;
            _not = false;
            return this;
        }

        public PropertyMap<T, TProperty> Selectable()
        {
            _property.IsSelectable = !_not;
            _not = false;
            return this;
        }

        public PropertyMap<T, TProperty> Serializable()
        {
            _property.IsSerializable = !_not;
            _not = false;
            return this;
        }

        public PropertyMap<T, TProperty> Sorted<TComparer>()
            where TComparer : class, IComparer
        {
            if (_property.IsListInterface)
            {
                _property.Sorted = new SortedAttribute { ComparerType = typeof(TComparer) };
            }
            _not = false;
            return this;
        }

        public PropertyMap<T, TProperty> Sorted()
        {
            if (_property.IsListInterface)
            {
                _property.Sorted = new SortedAttribute();
            }
            _not = false;
            return this;
        }

        public PropertyMap<T, TProperty> Distinct<TEqualityComparer>()
        {
            if (_property.IsListInterface && typeof(IEqualityComparer<>).MakeGenericType(_property.ElementType).IsAssignableFrom(typeof(TEqualityComparer)))
            {
                _property.Distinct = new DistinctAttribute { EqualityComparerType = typeof(TEqualityComparer) };
            }
            _not = false;
            return this;
        }

        public PropertyMap<T, TProperty> Distinct()
        {
            if (_property.IsListInterface)
            {
                _property.Distinct = new DistinctAttribute();
            }
            _not = false;
            return this;
        }

        public PropertyMap<T, TProperty> Column(string name)
        {
            _property.MappedColumnName = name;
            _not = false;
            return this;
        }

        public PropertyMap<T, TProperty> SourceProperty(string name)
        {
            _property.MappedPropertyName = name;
            _not = false;
            return this;
        }

        public PropertyMap<T, TProperty> WithTransform<TConverter>()
            where TConverter : class, ITypeConverter<object, TProperty>
        {
            _property.AddConverter(typeof(TConverter));
            return this;
        }

        ReflectedProperty IPropertyMap.Property
        {
            get { return _property; }
        }
    }
}
